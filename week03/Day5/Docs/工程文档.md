## 项目二：FTP客户端作业工程文档

### 一、项目流程

数据交互的流程如下所示：

<img src="https://cos-1301609895.cos.ap-nanjing.myqcloud.com/KingSummer/clipboard_20220726_025717.png">

### 二、项目架构设计

项目包含以下几个文件夹模块：client（客户端处理）、command（命令执行）、handler（命令分发）、pubtool（格式化打印、常量、文件处理、网络地址等工具类）、request-response（收发数据包）、sender（数据包发送中心）

<img src="https://cos-1301609895.cos.ap-nanjing.myqcloud.com/KingSummer/clipboard_20220726_040808.png">

以下介绍主要几个类

#### 1、KFtpClient

客户端封装类，定义客户端的一系列操作，此类面向用户，用于循环读取接收用户的输入命令、登录、连接FTP服务器等等

并在初始时会让用户选择主被动模式以及网络连接模式

**功能：**

- 选择主被动模式以及网络连接模式
- 连接FTP服务器
- 用户登录
- 循环接收用户指令

#### 2、KHandle

用于命令的分发处理，使用一个MAP结构存储对应的命令字符与处理类子类指针的映射关系

所有命令处理子类均会在初始化时构造一次

**功能：**

- 解析命令参数
- 提供命令名称与处理子类的映射关系，并将命令交由对应子类执行

#### 3、KCommand

##### （1）抽象基类

声明了纯虚方法`execute`，子类继承该父类仅需实现如何去实现该命令

经过总结将命令分为以下两类：需要数据收发、不需要数据收发；

需要数据收发的命令需要通过主动或被动模式建立一个数据收发的Socket、无需数据收发的命令接收回送数据即可

**功能：**

- 封装如下公共操作
  - 初始化数据库收发`KSocket`，根据项目初始配置选择主动或被动模式
  - 封装`KRequest`数据发送包（交由`KSender`发送）
  - 收发数据：接收长字符串（LIST命令）、收发文件（GET、PUT命令）
  - 发送`KRequest数据包`并获得`KResponse数据包`（封装了CODE状态码和MSG状态信息）

##### （2）各Command子类

`override`基类的`execute()`抽象方法，当我们需要添加一个命令参数时，就添加一个`KCommand`子类即可

**功能：**

- 完成各个命令的具体实现流程

  如：LIST命令的流为：发送PASV命令获得端口->发送LIST命令->进行数据的Socket连接接收数据

- 进行命令的参数校验

#### 4、KSender

数据包收发中心，程序唯一，将其指针传入各`KCommand`，由`KFtpClient`维护该指针

向上为`KCommand`提供数据包收发服务，向下通过`KSocket`向服务器进行数据收发

**功能：**

- 提供`KRequest`、`KResponse `和 字符串之间的转换
- 对命令发送长连接`Socket`、数据收发短连接`Socket`、主动模式的`ServerSocket`进行管管理
- 进行数据间的收发

### 三、项目思考

该项目进行过一次迭代

之前的老版本项目中，是没有`KSender`和`Request-Response`统一数据包这一层概念的，所有的数据收发与解析均由`KCommand`及其子类完成，导致`KCommand`这一层过于臃肿，也不利于后期扩展，于是加入了`统一数据收发中心-KSender`这一层概念，并加入了`Request-Response`统一数据包

于是新版本中的`KCommand`及其子类仅仅需完成命令流程的控制、参数校验以及数据包的封装即可，发送操作统一交由`KSender`处理

迭代完成后发现`KCommand`的处理逻辑相似，可以回归为几类：需要数据回送的命令与无需数据回送的命令，由于时间原因未能实现